// Copyright (c) 2008-2019, Hazelcast, Inc. All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections;
using System.Collections.Generic;
using Hazelcast.Client.Protocol;
using Hazelcast.Client.Protocol.Codec.BuiltIn;
using Hazelcast.Client.Protocol.Codec.Custom;
using Hazelcast.Client.Protocol.Util;
using Hazelcast.IO;
using Hazelcast.IO.Serialization;
using static Hazelcast.Client.Protocol.Codec.BuiltIn.FixedSizeTypesCodec;
using static Hazelcast.Client.Protocol.ClientMessage;
using static Hazelcast.IO.Bits;

namespace Hazelcast.Client.Protocol.Codec
{
    // This file is auto-generated by the Hazelcast Client Protocol Code Generator.
    // To change this file, edit the templates or the protocol
    // definitions on the https://github.com/hazelcast/hazelcast-client-protocol
    // and regenerate it.

    /// <summary>
    /// Adds a new cache configuration to a running cluster.
    /// If a cache configuration with the given {@code name} already exists, then
    /// the new configuration is ignored and the existing one is preserved.
    ///</summary>
    internal static class DynamicConfigAddCacheConfigCodec 
    {
        //hex: 0x1E1000
        public const int RequestMessageType = 1970176;
        //hex: 0x1E1001
        public const int ResponseMessageType = 1970177;
        private const int RequestStatisticsEnabledFieldOffset = PartitionIdFieldOffset + IntSizeInBytes;
        private const int RequestManagementEnabledFieldOffset = RequestStatisticsEnabledFieldOffset + BoolSizeInBytes;
        private const int RequestReadThroughFieldOffset = RequestManagementEnabledFieldOffset + BoolSizeInBytes;
        private const int RequestWriteThroughFieldOffset = RequestReadThroughFieldOffset + BoolSizeInBytes;
        private const int RequestBackupCountFieldOffset = RequestWriteThroughFieldOffset + BoolSizeInBytes;
        private const int RequestAsyncBackupCountFieldOffset = RequestBackupCountFieldOffset + IntSizeInBytes;
        private const int RequestDisablePerEntryInvalidationEventsFieldOffset = RequestAsyncBackupCountFieldOffset + IntSizeInBytes;
        private const int RequestInitialFrameSize = RequestDisablePerEntryInvalidationEventsFieldOffset + BoolSizeInBytes;
        private const int ResponseInitialFrameSize = ResponseBackupAcksFieldOffset + IntSizeInBytes;

        public class RequestParameters 
        {

            /// <summary>
            /// cache name
            ///</summary>
            public string Name;

            /// <summary>
            /// class name of key type
            ///</summary>
            public string KeyType;

            /// <summary>
            /// class name of value type
            ///</summary>
            public string ValueType;

            /// <summary>
            /// {@code true} to enable gathering of statistics, otherwise {@code false}
            ///</summary>
            public bool StatisticsEnabled;

            /// <summary>
            /// {@code true} to enable management interface on this cache or {@code false}
            ///</summary>
            public bool ManagementEnabled;

            /// <summary>
            /// {@code true} to enable read through from a {@code CacheLoader}
            ///</summary>
            public bool ReadThrough;

            /// <summary>
            /// {@code true} to enable write through to a {@code CacheWriter}
            ///</summary>
            public bool WriteThrough;

            /// <summary>
            /// name of cache loader factory class, if one is configured
            ///</summary>
            public string CacheLoaderFactory;

            /// <summary>
            /// name of cache writer factory class, if one is configured
            ///</summary>
            public string CacheWriterFactory;

            /// <summary>
            /// Factory                    name of cache loader factory class, if one is configured
            ///</summary>
            public string CacheLoader;

            /// <summary>
            /// Factory                    name of cache writer factory class, if one is configured
            ///</summary>
            public string CacheWriter;

            /// <summary>
            /// number of synchronous backups
            ///</summary>
            public int BackupCount;

            /// <summary>
            /// number of asynchronous backups
            ///</summary>
            public int AsyncBackupCount;

            /// <summary>
            /// data type used to store entries. Valid values are {@code BINARY},
            /// {@code OBJECT} and {@code NATIVE}.
            ///</summary>
            public string InMemoryFormat;

            /// <summary>
            /// name of an existing configured split brain protection to be used to determine the minimum
            /// number of members required in the cluster for the cache to remain functional.
            /// When {@code null}, split brain protection does not apply to this cache's operations.
            ///</summary>
            public string SplitBrainProtectionName;

            /// <summary>
            /// name of a class implementing {@link com.hazelcast.cache.CacheMergePolicy}
            /// that handles merging of values for this cache while recovering from
            /// network partitioning
            ///</summary>
            public string MergePolicy;

            /// <summary>
            /// when {@code true} disables invalidation events for per entry but
            /// full-flush invalidation events are still enabled.
            ///</summary>
            public bool DisablePerEntryInvalidationEvents;

            /// <summary>
            /// partition lost listener configurations
            ///</summary>
            public IEnumerable<com.hazelcast.client.impl.protocol.task.dynamicconfig.ListenerConfigHolder> PartitionLostListenerConfigs;

            /// <summary>
            /// expiry policy factory class name. When configuring an expiry policy,
            /// either this or {@ode timedExpiryPolicyFactoryConfig} should be configured.
            ///</summary>
            public string ExpiryPolicyFactoryClassName;

            /// <summary>
            /// expiry policy factory with duration configuration
            ///</summary>
            public com.hazelcast.config.CacheSimpleConfig.ExpiryPolicyFactoryConfig.TimedExpiryPolicyFactoryConfig TimedExpiryPolicyFactoryConfig;

            /// <summary>
            /// cache entry listeners configuration
            ///</summary>
            public IEnumerable<com.hazelcast.config.CacheSimpleEntryListenerConfig> CacheEntryListeners;

            /// <summary>
            /// cache eviction configuration
            ///</summary>
            public com.hazelcast.client.impl.protocol.task.dynamicconfig.EvictionConfigHolder EvictionConfig;

            /// <summary>
            /// reference to an existing WAN replication configuration
            ///</summary>
            public com.hazelcast.config.WanReplicationRef WanReplicationRef;

            /// <summary>
            /// Event Journal configuration
            ///</summary>
            public com.hazelcast.config.EventJournalConfig EventJournalConfig;

            /// <summary>
            /// hot restart configuration
            ///</summary>
            public com.hazelcast.config.HotRestartConfig HotRestartConfig;
        }

        public static ClientMessage EncodeRequest(string name, string keyType, string valueType, bool statisticsEnabled, bool managementEnabled, bool readThrough, bool writeThrough, string cacheLoaderFactory, string cacheWriterFactory, string cacheLoader, string cacheWriter, int backupCount, int asyncBackupCount, string inMemoryFormat, string splitBrainProtectionName, string mergePolicy, bool disablePerEntryInvalidationEvents, IEnumerable<com.hazelcast.client.impl.protocol.task.dynamicconfig.ListenerConfigHolder> partitionLostListenerConfigs, string expiryPolicyFactoryClassName, com.hazelcast.config.CacheSimpleConfig.ExpiryPolicyFactoryConfig.TimedExpiryPolicyFactoryConfig timedExpiryPolicyFactoryConfig, IEnumerable<com.hazelcast.config.CacheSimpleEntryListenerConfig> cacheEntryListeners, com.hazelcast.client.impl.protocol.task.dynamicconfig.EvictionConfigHolder evictionConfig, com.hazelcast.config.WanReplicationRef wanReplicationRef, com.hazelcast.config.EventJournalConfig eventJournalConfig, com.hazelcast.config.HotRestartConfig hotRestartConfig) 
        {
            var clientMessage = CreateForEncode();
            clientMessage.IsRetryable = false;
            clientMessage.AcquiresResource = false;
            clientMessage.OperationName = "DynamicConfig.AddCacheConfig";
            var initialFrame = new Frame(new byte[RequestInitialFrameSize], UnfragmentedMessage);
            EncodeInt(initialFrame.Content, TypeFieldOffset, RequestMessageType);
            EncodeBool(initialFrame.Content, RequestStatisticsEnabledFieldOffset, statisticsEnabled);
            EncodeBool(initialFrame.Content, RequestManagementEnabledFieldOffset, managementEnabled);
            EncodeBool(initialFrame.Content, RequestReadThroughFieldOffset, readThrough);
            EncodeBool(initialFrame.Content, RequestWriteThroughFieldOffset, writeThrough);
            EncodeInt(initialFrame.Content, RequestBackupCountFieldOffset, backupCount);
            EncodeInt(initialFrame.Content, RequestAsyncBackupCountFieldOffset, asyncBackupCount);
            EncodeBool(initialFrame.Content, RequestDisablePerEntryInvalidationEventsFieldOffset, disablePerEntryInvalidationEvents);
            clientMessage.Add(initialFrame);
            StringCodec.Encode(clientMessage, name);
            CodecUtil.EncodeNullable(clientMessage, keyType, StringCodec.Encode);
            CodecUtil.EncodeNullable(clientMessage, valueType, StringCodec.Encode);
            CodecUtil.EncodeNullable(clientMessage, cacheLoaderFactory, StringCodec.Encode);
            CodecUtil.EncodeNullable(clientMessage, cacheWriterFactory, StringCodec.Encode);
            CodecUtil.EncodeNullable(clientMessage, cacheLoader, StringCodec.Encode);
            CodecUtil.EncodeNullable(clientMessage, cacheWriter, StringCodec.Encode);
            StringCodec.Encode(clientMessage, inMemoryFormat);
            CodecUtil.EncodeNullable(clientMessage, splitBrainProtectionName, StringCodec.Encode);
            CodecUtil.EncodeNullable(clientMessage, mergePolicy, StringCodec.Encode);
            ListMultiFrameCodec.EncodeNullable(clientMessage, partitionLostListenerConfigs, ListenerConfigHolderCodec.Encode);
            CodecUtil.EncodeNullable(clientMessage, expiryPolicyFactoryClassName, StringCodec.Encode);
            CodecUtil.EncodeNullable(clientMessage, timedExpiryPolicyFactoryConfig, TimedExpiryPolicyFactoryConfigCodec.Encode);
            ListMultiFrameCodec.EncodeNullable(clientMessage, cacheEntryListeners, CacheSimpleEntryListenerConfigCodec.Encode);
            CodecUtil.EncodeNullable(clientMessage, evictionConfig, EvictionConfigHolderCodec.Encode);
            CodecUtil.EncodeNullable(clientMessage, wanReplicationRef, WanReplicationRefCodec.Encode);
            CodecUtil.EncodeNullable(clientMessage, eventJournalConfig, EventJournalConfigCodec.Encode);
            CodecUtil.EncodeNullable(clientMessage, hotRestartConfig, HotRestartConfigCodec.Encode);
            return clientMessage;
        }

        public static DynamicConfigAddCacheConfigCodec.RequestParameters DecodeRequest(ClientMessage clientMessage) 
        {
            var iterator = clientMessage.GetIterator();
            var request = new RequestParameters();
            var initialFrame = iterator.Next();
            request.StatisticsEnabled =  DecodeBool(initialFrame.Content, RequestStatisticsEnabledFieldOffset);
            request.ManagementEnabled =  DecodeBool(initialFrame.Content, RequestManagementEnabledFieldOffset);
            request.ReadThrough =  DecodeBool(initialFrame.Content, RequestReadThroughFieldOffset);
            request.WriteThrough =  DecodeBool(initialFrame.Content, RequestWriteThroughFieldOffset);
            request.BackupCount =  DecodeInt(initialFrame.Content, RequestBackupCountFieldOffset);
            request.AsyncBackupCount =  DecodeInt(initialFrame.Content, RequestAsyncBackupCountFieldOffset);
            request.DisablePerEntryInvalidationEvents =  DecodeBool(initialFrame.Content, RequestDisablePerEntryInvalidationEventsFieldOffset);
            request.Name = StringCodec.Decode(ref iterator);
            request.KeyType = CodecUtil.DecodeNullable(ref iterator, StringCodec.Decode);
            request.ValueType = CodecUtil.DecodeNullable(ref iterator, StringCodec.Decode);
            request.CacheLoaderFactory = CodecUtil.DecodeNullable(ref iterator, StringCodec.Decode);
            request.CacheWriterFactory = CodecUtil.DecodeNullable(ref iterator, StringCodec.Decode);
            request.CacheLoader = CodecUtil.DecodeNullable(ref iterator, StringCodec.Decode);
            request.CacheWriter = CodecUtil.DecodeNullable(ref iterator, StringCodec.Decode);
            request.InMemoryFormat = StringCodec.Decode(ref iterator);
            request.SplitBrainProtectionName = CodecUtil.DecodeNullable(ref iterator, StringCodec.Decode);
            request.MergePolicy = CodecUtil.DecodeNullable(ref iterator, StringCodec.Decode);
            request.PartitionLostListenerConfigs = ListMultiFrameCodec.DecodeNullable(ref iterator, ListenerConfigHolderCodec.Decode);
            request.ExpiryPolicyFactoryClassName = CodecUtil.DecodeNullable(ref iterator, StringCodec.Decode);
            request.TimedExpiryPolicyFactoryConfig = CodecUtil.DecodeNullable(ref iterator, TimedExpiryPolicyFactoryConfigCodec.Decode);
            request.CacheEntryListeners = ListMultiFrameCodec.DecodeNullable(ref iterator, CacheSimpleEntryListenerConfigCodec.Decode);
            request.EvictionConfig = CodecUtil.DecodeNullable(ref iterator, EvictionConfigHolderCodec.Decode);
            request.WanReplicationRef = CodecUtil.DecodeNullable(ref iterator, WanReplicationRefCodec.Decode);
            request.EventJournalConfig = CodecUtil.DecodeNullable(ref iterator, EventJournalConfigCodec.Decode);
            request.HotRestartConfig = CodecUtil.DecodeNullable(ref iterator, HotRestartConfigCodec.Decode);
            return request;
        }

        public class ResponseParameters 
        {
        }

        public static ClientMessage EncodeResponse() 
        {
            var clientMessage = CreateForEncode();
            var initialFrame = new Frame(new byte[ResponseInitialFrameSize], UnfragmentedMessage);
            EncodeInt(initialFrame.Content, TypeFieldOffset, ResponseMessageType);
            clientMessage.Add(initialFrame);

            return clientMessage;
        }

        public static DynamicConfigAddCacheConfigCodec.ResponseParameters DecodeResponse(ClientMessage clientMessage)
        {
            var iterator = clientMessage.GetIterator();
            var response = new ResponseParameters();
            //empty initial frame
            iterator.Next();
            return response;
        }
    }
}