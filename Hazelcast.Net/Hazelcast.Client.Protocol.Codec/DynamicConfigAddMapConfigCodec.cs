// Copyright (c) 2008-2019, Hazelcast, Inc. All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections;
using System.Collections.Generic;
using Hazelcast.Client.Protocol;
using Hazelcast.Client.Protocol.Codec.BuiltIn;
using Hazelcast.Client.Protocol.Codec.Custom;
using Hazelcast.Client.Protocol.Util;
using Hazelcast.IO;
using Hazelcast.IO.Serialization;
using static Hazelcast.Client.Protocol.Codec.BuiltIn.FixedSizeTypesCodec;
using static Hazelcast.Client.Protocol.ClientMessage;
using static Hazelcast.IO.Bits;

namespace Hazelcast.Client.Protocol.Codec
{
    // This file is auto-generated by the Hazelcast Client Protocol Code Generator.
    // To change this file, edit the templates or the protocol
    // definitions on the https://github.com/hazelcast/hazelcast-client-protocol
    // and regenerate it.

    /// <summary>
    /// Adds a new map configuration to a running cluster.
    /// If a map configuration with the given {@code name} already exists, then
    /// the new configuration is ignored and the existing one is preserved.
    ///</summary>
    internal static class DynamicConfigAddMapConfigCodec 
    {
        //hex: 0x1B0C00
        public const int RequestMessageType = 1772544;
        //hex: 0x1B0C01
        public const int ResponseMessageType = 1772545;
        private const int RequestBackupCountFieldOffset = PartitionIdFieldOffset + IntSizeInBytes;
        private const int RequestAsyncBackupCountFieldOffset = RequestBackupCountFieldOffset + IntSizeInBytes;
        private const int RequestTimeToLiveSecondsFieldOffset = RequestAsyncBackupCountFieldOffset + IntSizeInBytes;
        private const int RequestMaxIdleSecondsFieldOffset = RequestTimeToLiveSecondsFieldOffset + IntSizeInBytes;
        private const int RequestReadBackupDataFieldOffset = RequestMaxIdleSecondsFieldOffset + IntSizeInBytes;
        private const int RequestStatisticsEnabledFieldOffset = RequestReadBackupDataFieldOffset + BoolSizeInBytes;
        private const int RequestMaxSizeConfigSizeFieldOffset = RequestStatisticsEnabledFieldOffset + BoolSizeInBytes;
        private const int RequestMergeBatchSizeFieldOffset = RequestMaxSizeConfigSizeFieldOffset + IntSizeInBytes;
        private const int RequestMetadataPolicyFieldOffset = RequestMergeBatchSizeFieldOffset + IntSizeInBytes;
        private const int RequestInitialFrameSize = RequestMetadataPolicyFieldOffset + IntSizeInBytes;
        private const int ResponseInitialFrameSize = ResponseBackupAcksFieldOffset + IntSizeInBytes;

        public class RequestParameters 
        {

            /// <summary>
            /// TODO DOC
            ///</summary>
            public string Name;

            /// <summary>
            /// number of synchronous backups
            ///</summary>
            public int BackupCount;

            /// <summary>
            /// number of asynchronous backups
            ///</summary>
            public int AsyncBackupCount;

            /// <summary>
            /// maximum number of seconds for each entry to stay in the map.
            ///</summary>
            public int TimeToLiveSeconds;

            /// <summary>
            /// maximum number of seconds for each entry to stay idle in the map
            ///</summary>
            public int MaxIdleSeconds;

            /// <summary>
            /// eviction policy. Valid values: {@code NONE} (no eviction), {@code LRU}
            /// (Least Recently Used), {@code LFU} (Least Frequently Used),
            /// {@code RANDOM} (evict random entry).
            ///</summary>
            public string EvictionPolicy;

            /// <summary>
            /// {@code true} to enable reading local backup entries, {@code false} otherwise
            ///</summary>
            public bool ReadBackupData;

            /// <summary>
            /// control caching of de-serialized values. Valid values are {@code NEVER}
            /// (Never cache de-serialized object), {@code INDEX_ONLY} (Cache values only
            /// when they are inserted into an index) and {@code ALWAYS} (Always cache
            /// de-serialized values
            ///</summary>
            public string CacheDeserializedValues;

            /// <summary>
            /// class name of a class implementing
            /// {@code com.hazelcast.map.merge.MapMergePolicy} to merge entries
            /// while recovering from a split brain
            ///</summary>
            public string MergePolicy;

            /// <summary>
            /// data type used to store entries. Valid values are {@code BINARY},
            /// {@code OBJECT} and {@code NATIVE}.
            ///</summary>
            public string InMemoryFormat;

            /// <summary>
            /// entry listener configurations
            ///</summary>
            public IList<com.hazelcast.client.impl.protocol.task.dynamicconfig.ListenerConfigHolder> ListenerConfigs;

            /// <summary>
            /// partition lost listener configurations
            ///</summary>
            public IList<com.hazelcast.client.impl.protocol.task.dynamicconfig.ListenerConfigHolder> PartitionLostListenerConfigs;

            /// <summary>
            /// {@code true} to enable gathering of statistics, otherwise {@code false}
            ///</summary>
            public bool StatisticsEnabled;

            /// <summary>
            /// name of an existing configured split brain protection to be used to determine the minimum
            /// number of members required in the cluster for the map to remain functional.
            /// When {@code null}, split brain protection does not apply to this map's operations.
            ///</summary>
            public string SplitBrainProtectionName;

            /// <summary>
            /// custom {@code com.hazelcast.map.eviction.MapEvictionPolicy} implementation
            /// or {@code null}
            ///</summary>
            public IData MapEvictionPolicy;

            /// <summary>
            /// maximum size policy. Valid values are {@code PER_NODE},
            /// {@code PER_PARTITION}, {@code USED_HEAP_PERCENTAGE}, {@code USED_HEAP_SIZE},
            /// {@code FREE_HEAP_PERCENTAGE}, {@code FREE_HEAP_SIZE},
            /// {@code USED_NATIVE_MEMORY_SIZE}, {@code USED_NATIVE_MEMORY_PERCENTAGE},
            /// {@code FREE_NATIVE_MEMORY_SIZE}, {@code FREE_NATIVE_MEMORY_PERCENTAGE}.
            ///</summary>
            public string MaxSizeConfigMaxSizePolicy;

            /// <summary>
            /// maximum size of map
            ///</summary>
            public int MaxSizeConfigSize;

            /// <summary>
            /// configuration of backing map store or {@code null} for none
            ///</summary>
            public com.hazelcast.client.impl.protocol.task.dynamicconfig.MapStoreConfigHolder MapStoreConfig;

            /// <summary>
            /// configuration of near cache or {@code null} for none
            ///</summary>
            public com.hazelcast.client.impl.protocol.task.dynamicconfig.NearCacheConfigHolder NearCacheConfig;

            /// <summary>
            /// reference to an existing WAN replication configuration
            ///</summary>
            public com.hazelcast.config.WanReplicationRef WanReplicationRef;

            /// <summary>
            /// index configurations
            ///</summary>
            public IList<com.hazelcast.config.IndexConfig> IndexConfigs;

            /// <summary>
            /// map attributes
            ///</summary>
            public IList<com.hazelcast.config.AttributeConfig> AttributeConfigs;

            /// <summary>
            /// configurations for query caches on this map
            ///</summary>
            public IList<com.hazelcast.client.impl.protocol.task.dynamicconfig.QueryCacheConfigHolder> QueryCacheConfigs;

            /// <summary>
            /// name of class implementing {@code com.hazelcast.core.PartitioningStrategy}
            /// or {@code null}
            ///</summary>
            public string PartitioningStrategyClassName;

            /// <summary>
            /// a serialized instance of a partitioning strategy
            ///</summary>
            public IData PartitioningStrategyImplementation;

            /// <summary>
            /// hot restart configuration
            ///</summary>
            public com.hazelcast.config.HotRestartConfig HotRestartConfig;

            /// <summary>
            /// Event Journal configuration
            ///</summary>
            public com.hazelcast.config.EventJournalConfig EventJournalConfig;

            /// <summary>
            /// - merkle tree configuration
            ///</summary>
            public com.hazelcast.config.MerkleTreeConfig MerkleTreeConfig;

            /// <summary>
            /// TODO DOC
            ///</summary>
            public int MergeBatchSize;

            /// <summary>
            /// metadata policy configuration for the supported data types. Valid values
            /// are {@code CREATE_ON_UPDATE} and {@code OFF}
            ///</summary>
            public int MetadataPolicy;
        }

        public static ClientMessage EncodeRequest(string name, int backupCount, int asyncBackupCount, int timeToLiveSeconds, int maxIdleSeconds, string evictionPolicy, bool readBackupData, string cacheDeserializedValues, string mergePolicy, string inMemoryFormat, IEnumerable<com.hazelcast.client.impl.protocol.task.dynamicconfig.ListenerConfigHolder> listenerConfigs, IEnumerable<com.hazelcast.client.impl.protocol.task.dynamicconfig.ListenerConfigHolder> partitionLostListenerConfigs, bool statisticsEnabled, string splitBrainProtectionName, IData mapEvictionPolicy, string maxSizeConfigMaxSizePolicy, int maxSizeConfigSize, com.hazelcast.client.impl.protocol.task.dynamicconfig.MapStoreConfigHolder mapStoreConfig, com.hazelcast.client.impl.protocol.task.dynamicconfig.NearCacheConfigHolder nearCacheConfig, com.hazelcast.config.WanReplicationRef wanReplicationRef, IEnumerable<com.hazelcast.config.IndexConfig> indexConfigs, IEnumerable<com.hazelcast.config.AttributeConfig> attributeConfigs, IEnumerable<com.hazelcast.client.impl.protocol.task.dynamicconfig.QueryCacheConfigHolder> queryCacheConfigs, string partitioningStrategyClassName, IData partitioningStrategyImplementation, com.hazelcast.config.HotRestartConfig hotRestartConfig, com.hazelcast.config.EventJournalConfig eventJournalConfig, com.hazelcast.config.MerkleTreeConfig merkleTreeConfig, int mergeBatchSize, int metadataPolicy) 
        {
            var clientMessage = CreateForEncode();
            clientMessage.IsRetryable = false;
            clientMessage.AcquiresResource = false;
            clientMessage.OperationName = "DynamicConfig.AddMapConfig";
            var initialFrame = new Frame(new byte[RequestInitialFrameSize], UnfragmentedMessage);
            EncodeInt(initialFrame.Content, TypeFieldOffset, RequestMessageType);
            EncodeInt(initialFrame.Content, RequestBackupCountFieldOffset, backupCount);
            EncodeInt(initialFrame.Content, RequestAsyncBackupCountFieldOffset, asyncBackupCount);
            EncodeInt(initialFrame.Content, RequestTimeToLiveSecondsFieldOffset, timeToLiveSeconds);
            EncodeInt(initialFrame.Content, RequestMaxIdleSecondsFieldOffset, maxIdleSeconds);
            EncodeBool(initialFrame.Content, RequestReadBackupDataFieldOffset, readBackupData);
            EncodeBool(initialFrame.Content, RequestStatisticsEnabledFieldOffset, statisticsEnabled);
            EncodeInt(initialFrame.Content, RequestMaxSizeConfigSizeFieldOffset, maxSizeConfigSize);
            EncodeInt(initialFrame.Content, RequestMergeBatchSizeFieldOffset, mergeBatchSize);
            EncodeInt(initialFrame.Content, RequestMetadataPolicyFieldOffset, metadataPolicy);
            clientMessage.Add(initialFrame);
            StringCodec.Encode(clientMessage, name);
            StringCodec.Encode(clientMessage, evictionPolicy);
            StringCodec.Encode(clientMessage, cacheDeserializedValues);
            StringCodec.Encode(clientMessage, mergePolicy);
            StringCodec.Encode(clientMessage, inMemoryFormat);
            ListMultiFrameCodec.EncodeNullable(clientMessage, listenerConfigs, ListenerConfigHolderCodec.Encode);
            ListMultiFrameCodec.EncodeNullable(clientMessage, partitionLostListenerConfigs, ListenerConfigHolderCodec.Encode);
            CodecUtil.EncodeNullable(clientMessage, splitBrainProtectionName, StringCodec.Encode);
            CodecUtil.EncodeNullable(clientMessage, mapEvictionPolicy, DataCodec.Encode);
            StringCodec.Encode(clientMessage, maxSizeConfigMaxSizePolicy);
            CodecUtil.EncodeNullable(clientMessage, mapStoreConfig, MapStoreConfigHolderCodec.Encode);
            CodecUtil.EncodeNullable(clientMessage, nearCacheConfig, NearCacheConfigHolderCodec.Encode);
            CodecUtil.EncodeNullable(clientMessage, wanReplicationRef, WanReplicationRefCodec.Encode);
            ListMultiFrameCodec.EncodeNullable(clientMessage, indexConfigs, IndexConfigCodec.Encode);
            ListMultiFrameCodec.EncodeNullable(clientMessage, attributeConfigs, AttributeConfigCodec.Encode);
            ListMultiFrameCodec.EncodeNullable(clientMessage, queryCacheConfigs, QueryCacheConfigHolderCodec.Encode);
            CodecUtil.EncodeNullable(clientMessage, partitioningStrategyClassName, StringCodec.Encode);
            CodecUtil.EncodeNullable(clientMessage, partitioningStrategyImplementation, DataCodec.Encode);
            CodecUtil.EncodeNullable(clientMessage, hotRestartConfig, HotRestartConfigCodec.Encode);
            CodecUtil.EncodeNullable(clientMessage, eventJournalConfig, EventJournalConfigCodec.Encode);
            CodecUtil.EncodeNullable(clientMessage, merkleTreeConfig, MerkleTreeConfigCodec.Encode);
            return clientMessage;
        }

        public static DynamicConfigAddMapConfigCodec.RequestParameters DecodeRequest(ClientMessage clientMessage) 
        {
            var iterator = clientMessage.GetIterator();
            var request = new RequestParameters();
            var initialFrame = iterator.Next();
            request.BackupCount =  DecodeInt(initialFrame.Content, RequestBackupCountFieldOffset);
            request.AsyncBackupCount =  DecodeInt(initialFrame.Content, RequestAsyncBackupCountFieldOffset);
            request.TimeToLiveSeconds =  DecodeInt(initialFrame.Content, RequestTimeToLiveSecondsFieldOffset);
            request.MaxIdleSeconds =  DecodeInt(initialFrame.Content, RequestMaxIdleSecondsFieldOffset);
            request.ReadBackupData =  DecodeBool(initialFrame.Content, RequestReadBackupDataFieldOffset);
            request.StatisticsEnabled =  DecodeBool(initialFrame.Content, RequestStatisticsEnabledFieldOffset);
            request.MaxSizeConfigSize =  DecodeInt(initialFrame.Content, RequestMaxSizeConfigSizeFieldOffset);
            request.MergeBatchSize =  DecodeInt(initialFrame.Content, RequestMergeBatchSizeFieldOffset);
            request.MetadataPolicy =  DecodeInt(initialFrame.Content, RequestMetadataPolicyFieldOffset);
            request.Name = StringCodec.Decode(ref iterator);
            request.EvictionPolicy = StringCodec.Decode(ref iterator);
            request.CacheDeserializedValues = StringCodec.Decode(ref iterator);
            request.MergePolicy = StringCodec.Decode(ref iterator);
            request.InMemoryFormat = StringCodec.Decode(ref iterator);
            request.ListenerConfigs = ListMultiFrameCodec.DecodeNullable(ref iterator, ListenerConfigHolderCodec.Decode);
            request.PartitionLostListenerConfigs = ListMultiFrameCodec.DecodeNullable(ref iterator, ListenerConfigHolderCodec.Decode);
            request.SplitBrainProtectionName = CodecUtil.DecodeNullable(ref iterator, StringCodec.Decode);
            request.MapEvictionPolicy = CodecUtil.DecodeNullable(ref iterator, DataCodec.Decode);
            request.MaxSizeConfigMaxSizePolicy = StringCodec.Decode(ref iterator);
            request.MapStoreConfig = CodecUtil.DecodeNullable(ref iterator, MapStoreConfigHolderCodec.Decode);
            request.NearCacheConfig = CodecUtil.DecodeNullable(ref iterator, NearCacheConfigHolderCodec.Decode);
            request.WanReplicationRef = CodecUtil.DecodeNullable(ref iterator, WanReplicationRefCodec.Decode);
            request.IndexConfigs = ListMultiFrameCodec.DecodeNullable(ref iterator, IndexConfigCodec.Decode);
            request.AttributeConfigs = ListMultiFrameCodec.DecodeNullable(ref iterator, AttributeConfigCodec.Decode);
            request.QueryCacheConfigs = ListMultiFrameCodec.DecodeNullable(ref iterator, QueryCacheConfigHolderCodec.Decode);
            request.PartitioningStrategyClassName = CodecUtil.DecodeNullable(ref iterator, StringCodec.Decode);
            request.PartitioningStrategyImplementation = CodecUtil.DecodeNullable(ref iterator, DataCodec.Decode);
            request.HotRestartConfig = CodecUtil.DecodeNullable(ref iterator, HotRestartConfigCodec.Decode);
            request.EventJournalConfig = CodecUtil.DecodeNullable(ref iterator, EventJournalConfigCodec.Decode);
            request.MerkleTreeConfig = CodecUtil.DecodeNullable(ref iterator, MerkleTreeConfigCodec.Decode);
            return request;
        }

        public class ResponseParameters 
        {
        }

        public static ClientMessage EncodeResponse() 
        {
            var clientMessage = CreateForEncode();
            var initialFrame = new Frame(new byte[ResponseInitialFrameSize], UnfragmentedMessage);
            EncodeInt(initialFrame.Content, TypeFieldOffset, ResponseMessageType);
            clientMessage.Add(initialFrame);

            return clientMessage;
        }

        public static DynamicConfigAddMapConfigCodec.ResponseParameters DecodeResponse(ClientMessage clientMessage)
        {
            var iterator = clientMessage.GetIterator();
            var response = new ResponseParameters();
            //empty initial frame
            iterator.Next();
            return response;
        }
    }
}