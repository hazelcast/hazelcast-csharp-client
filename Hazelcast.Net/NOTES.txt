
#### NOTES ABOUT ATOMICITY

Partition I, Section 12.6.6 of the CLI spec states: "A conforming CLI shall guarantee
that read and write access to properly aligned memory locations no larger than the native
word size is atomic when all the write accesses to a location are the same size."

And, C# specs section 5.5 states: "Reads and writes of the following data types are
atomic: bool, char, byte, sbyte, short, ushort, uint, int, float, and reference types.
In addition, reads and writes of enum types with an underlying type in the previous
list are also atomic. Reads and writes of other types, including long, ulong, double,
and decimal, as well as user-defined types, are not guaranteed to be atomic."

However - atomic does not imply thread-safety due to the processor reordering reads and
writes. The variables should be marked volatile, or accessed through Interlocked.

References
https://stackoverflow.com/questions/9666/is-accessing-a-variable-in-c-sharp-an-atomic-operation
https://stackoverflow.com/questions/2433772/are-primitive-data-types-in-c-sharp-atomic-thread-safe

So,
Anything safe as per section 5.5 quoted above has to be volatile
Anything not safe has to be Interlocked.


#### NOTES ABOUT HASHING

In most cases, we keep the original hashing code instead of replacing it with more
recent and more efficient code available for instance in netstandard 2.1, because before
we replace the code we need to make sure that it is OK wrt the other clients.


        // NOTES
        //
        // read
        //  danger of completion source
        //    https://devblogs.microsoft.com/premier-developer/the-danger-of-taskcompletionsourcet-class/
        //
        // sending: we can either queue messages, or just send them immediately
        //  it does not make a diff for user, who's going to wait anyways
        //  but queueing may prevent flooding the server
        //  and, in order to be multi-threaded, we HAVE to serialize the sending
        //  of messages through the socket - either by queuing or by forcing
        //  the client to wait - which is kind of a nice way to apply back-
        //  pressure?
        //
        // TODO
        //  must: implement something, lock in connection
        //  alternative: implement queuing in connection
        //
        // receiving: we process messages immediately so there is no queuing of
        //  messages - should we have some?
        //
        // TODO: understand the schedulers in HZ code
