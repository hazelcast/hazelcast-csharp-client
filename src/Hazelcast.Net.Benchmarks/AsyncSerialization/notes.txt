run with: hz build && src/Hazelcast.Net.Benchmarks/bin/Release/netcoreapp5.0/hb.exe AsyncSerialization.AsyncSerializationBare

AsyncSerializationBare

    No serialization is involved. The objective is to evaluate the bare cost of async vs async, both for
    - true async, where the invoked async method runs the async state machine
    - non async, where the invoked async methods synchronously returns a completed ValueTask<>

    |        Method |        Mean |     Error |    StdDev |  Ratio | RatioSD |   Gen 0 | Allocated |
    |-------------- |------------:|----------:|----------:|-------:|--------:|--------:|----------:|
    |          Sync |    10.15 us |  0.149 us |  0.139 us |   1.00 |    0.00 |  0.0305 |     136 B |
    | BareTrueAsync | 1,047.54 us | 12.255 us | 11.463 us | 103.23 |    1.66 | 31.2500 | 128,232 B |
    |  BareNonAsync |    22.74 us |  0.454 us |  0.445 us |   2.24 |    0.05 |  0.0305 |     175 B |

    These results show that the true async is ~100 times slower, whereas the non async is only ~2.2 times slower. Another
    maybe more useful way to read the results is that true async introduces a ~1,050 us overhead, whereas non async
    introduces a ~12 us overhead.

AsyncSerializationInteger

    Serialization of a simple int value.

    |                    Method |         Mean |      Error |     StdDev |       Median |  Ratio | RatioSD |    Gen 0 | Allocated |
    |-------------------------- |-------------:|-----------:|-----------:|-------------:|-------:|--------:|---------:|----------:|
    |                      Sync |     74.65 us |   1.471 us |   2.970 us |     74.19 us |   1.00 |    0.00 |  17.2119 |     71 KB |
    |                     Async |  1,207.83 us |  20.906 us |  19.555 us |  1,209.13 us |  16.40 |    0.39 |  46.8750 |    196 KB |
    |        AsyncOptimizedBest |     93.19 us |   1.862 us |   4.773 us |     92.30 us |   1.25 |    0.09 |  17.2119 |     71 KB |
    |       AsyncOptimizedWorst |  1,242.53 us |  24.658 us |  35.364 us |  1,227.44 us |  16.71 |    0.92 |  46.8750 |    196 KB |
    |       AsyncOptimized2Best |     81.77 us |   1.412 us |   1.251 us |     81.48 us |   1.11 |    0.03 |  17.2119 |     71 KB |
    |      AsyncOptimized2Worst |  1,213.42 us |   8.491 us |   7.090 us |  1,215.40 us |  16.42 |    0.32 |  46.8750 |    196 KB |
    |  SyncOrFalseThenAsyncBest |     87.65 us |   2.017 us |   5.851 us |     84.89 us |   1.18 |    0.10 |  17.2119 |     71 KB |
    | SyncOrFalseThenAsyncWorst |  1,215.42 us |  17.711 us |  16.567 us |  1,210.06 us |  16.50 |    0.34 |  46.8750 |    196 KB |
    |  SyncOrThrowThenAsyncBest |     85.46 us |   1.705 us |   4.150 us |     84.07 us |   1.15 |    0.07 |  17.2119 |     71 KB |
    | SyncOrThrowThenAsyncWorst | 11,698.90 us | 287.774 us | 839.450 us | 11,428.19 us | 158.29 |   14.21 | 125.0000 |    508 KB |

    AsyncOptimized returns a ValueTask<> if possible, else goes the true async way. We drive the benchmark with a
    condition which, in the 'best' case, is always true, and in the 'worst' case, is always false.

    The result show that an optimized async version synchronously returning a ValueTask<> when possible introduces a
    ~20 us overhead, which is consistent with the Bare benchmark. Of course, triggering the true async state machine
    has a cost, which here is ~1,130 us, again consistent with the Bare benchmark. In terms of ratios, it means that
    the best case is still 25% slower, versus sync, though.

    The AsyncOptimized2 version does the condition test at the caller's side instead of doing it in the invoked method,
    SyncOrFalseThenAsync signals whether a sync execution is possible via a boolean, and SyncOrThrowThenAsync signals
    whether a sync execution is possible via an exception. We see that they provide marginally better results, at the
    expense of more complex code.

AsyncSerializationPortable

    Serialization of a simple portable class.

    |                    Method |        Mean |     Error |      StdDev | Ratio | RatioSD |    Gen 0 | Allocated |
    |-------------------------- |------------:|----------:|------------:|------:|--------:|---------:|----------:|
    |                      Sync |    336.5 us |   6.73 us |    14.04 us |  1.00 |    0.00 |  61.0352 |    250 KB |
    |                     Async |  1,534.9 us |  31.93 us |    94.13 us |  4.56 |    0.35 |  91.7969 |    375 KB |
    |        AsyncOptimizedBest |    377.2 us |   7.52 us |    14.67 us |  1.12 |    0.06 |  61.0352 |    250 KB |
    |       AsyncOptimizedWorst |  1,631.4 us |  32.58 us |    38.78 us |  4.87 |    0.23 |  91.7969 |    375 KB |
    |       AsyncOptimized2Best |    366.9 us |   7.94 us |    22.38 us |  1.13 |    0.08 |  61.0352 |    250 KB |
    |      AsyncOptimized2Worst |  1,525.5 us |  29.61 us |    82.55 us |  4.55 |    0.35 |  91.7969 |    375 KB |
    |  SyncOrFalseThenAsyncBest |    345.8 us |   6.79 us |    11.15 us |  1.03 |    0.04 |  61.0352 |    250 KB |
    | SyncOrFalseThenAsyncWorst |  1,522.7 us |  30.23 us |    75.84 us |  4.56 |    0.28 |  91.7969 |    375 KB |
    |  SyncOrThrowThenAsyncBest |    345.3 us |   6.58 us |    10.63 us |  1.03 |    0.06 |  61.0352 |    250 KB |
    | SyncOrThrowThenAsyncWorst | 12,676.6 us | 396.97 us | 1,145.34 us | 37.89 |    3.62 | 156.2500 |    688 KB |

    The result show that an optimized async version synchronously returning a ValueTask<> when possible introduces a
    ~40 us overhead, which remains consistent with the Bare benchmark. True async adds ~1,200 us and remains again
    consistent. In terms of ratio, we get down to 12% slower.

    Note: still, I don't explain why the overheads are larger.

    Since all ratios go down, the SyncOrFalse or SyncOrThrow ratios fall below 5%. We definitively want to avoid
    the SyncOrThrow version as the worst-case cost is quite expensive and exceptions are not meant to be used like
    that, but the SyncOrFalse could be an option - which needs to be balanced against the associated quite more
    complicated code pattern.

AsyncSerialization

    Requirements
    - 2 members, 1 client, 1 thread
    - 4 variations:
      - puts as per master
      - puts with 'eager de-serialization' + 'controlled serialization'
      - gets as per master
      - gets with 'eager de-serialization' + 'controlled serialization'

    Where
    - 'eager deserialization' = we deserialize *everything* we receive before returning to the user, i.e. while
      we are still in the async call, so that we can asynchronously fetch missing schemas if needed.
    - 'controlled serialization' = the serializer throws (or reports in any meaningful way) when it cannot
      serialize, synchronously, and then the caller fetches the schemas, and then tries again.

    Notes
    - 'eager deserialization' means we kill lazy-values support everywhere in the .NET client = bad
    - alternative is async-lazy-values which means that every value access has to become async = expensive

    Put

    | Method |     Mean |    Error |   StdDev | Ratio | RatioSD |    Gen 0 | Allocated |
    |------- |---------:|---------:|---------:|------:|--------:|---------:|----------:|
    |    Put | 17.65 ms | 0.339 ms | 0.813 ms |  1.00 |    0.00 | 250.0000 |      1 MB |
    |   Put2 | 17.21 ms | 0.355 ms | 1.024 ms |  0.99 |    0.07 | 250.0000 |      1 MB |

    As far as Put is concerned, we are marginally faster thanks to a marginal refactoring of the method, so it
    probably is fair to say that the impact is non-detectable or can be mitigated - because the overheads we
    were discussing above are few orders of magnitude smaller than the actual duration of a put operation?

    Get

    | Method |     Mean |    Error |   StdDev | Ratio | RatioSD |    Gen 0 | Allocated |
    |------- |---------:|---------:|---------:|------:|--------:|---------:|----------:|
    |    Get | 18.71 ms | 0.536 ms | 1.485 ms |  1.00 |    0.00 | 156.2500 |    671 KB |
    |   Get2 | 17.29 ms | 0.338 ms | 0.810 ms |  0.92 |    0.09 | 156.2500 |    644 KB |

    Similar results for Get, a clear rewrite of the method with less clutter and less chained async state
    machines even creates a small perf gain.

    So we can even probably improve perf by paying more attentions to our async methods chains, and do the
    eager / controlled thing without a performance loss. OTOH, eager is *not* compatible with lazy?

Discussion

    Turning a sync method into an async method *has* a non-null performance penalty.
    Either we accept it, or?
    Any missing schema situation blows into the face of the user.

    For reading, we *could* go the exception way + enqueue the schema request into a background queue, that would
    fetch it from the server, and since the invocation would be retried... eventually it could succeed. Except,
    that does not apply to anything lazy-deserialized.

    For writing, that is not going to work as the invocation is not retryable by default. So either we don't
    support it at all, or we need to accept that ToData takes the penalty (and maybe not ToObject)?

    'Controlled serialization' pretty much is SyncOrThrow in the original design, we'd probably better want
    to use SyncOrFalse, and accept the code complexity around each ToData calls. That probably can be done.

    'Eager deserialization' seems like a big meh for .NET?