<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Locking | Hazelcast .NET Documentation </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Locking | Hazelcast .NET Documentation ">
    
      <link rel="shortcut icon" href="../../images/favicon.ico">
      <link rel="stylesheet" href="../../styles/docfx.vendor.min.css">
      <link rel="stylesheet" href="../../styles/docfx.css">
      <link rel="stylesheet" href="../../styles/main.css">
      <link rel="stylesheet" href="../../styles/hz.css">
      <meta property="docfx:navrel" content="../toc.html">
      <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper" class="">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../index.html">
                <img id="logo" src="../../images/hazelcast-white.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
              <div class="brandcrumb">.NET Client Documentation<br>5.5.1</div>
              <div id="breadhtml">
                <ul class="breadcrumb">
                  <li></li>
                </ul>
              </div>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first=First data-prev=Previous data-next=Next data-last=Last></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="locking">Locking</h1>

<p>On the server (member) side, Hazelcast uses a unique number to identify the owner of locks, and historically that number has always been the thread unique identifier. As a consequence, the locking model in previous versions of the Hazelcast client closely match the thread-based model that .NET provides with, for instance, the <code>lock</code> statement.</p>
<p>Due to the systematic usage of asynchronous patterns, the code for one operation can be executed by many different threads (basically, each time an operation is put on hold by an <code>await</code> statement, it can resume its execution on any other thread). Therefore, using the actual thread identifier as a &quot;lock owner&quot; identifier is not possible anymore.</p>
<p>The Hazelcast .NET client introduces different ways to manage the context of a lock in an asynchronous pattern.</p>
<h2 id="implicit-context">Implicit Context</h2>
<p>For things such as maps, that would implicitly rely on the thread identifier to identify their lock context, the Hazelcast .NET client implicitly manages a &quot;lock context&quot;.
This allows the API to remain similar enough to the version 3 API.
The lock context is represented by an <code>AsyncContext</code> instance.
This is a class which relies upon the .NET built-in <code>AsyncLocal&lt;T&gt;</code> type to maintain values that flow with the asynchronous operation, i.e. are transferred to the new thread when an operation resumes after awaiting.
Therefore, when an operation acquires a lock, it owns the lock until it releases it, no matter what thread executes the operation.
The <code>AsyncContext</code> uses a sequential number to ensure the uniqueness of the identifier.</p>
<p>In order to execute work in a new context (which would correspond to executing work on a different thread for previous versions), one has to use a new context:</p>
<pre><code class="lang-csharp">// executes in the same, current context
await DoSomethingAsync(...);

using (AsyncContext.New())
{
    // executes in a new context
    await DoSomethingAsync(...);
}
</code></pre>
<p>Due to the way <code>AsyncLocal&lt;T&gt;</code> variables work, <em>any task</em> started from within the <code>using</code> block executes in the new context, even if it continues to execute after the <code>using</code> block has exited:</p>
<pre><code class="lang-csharp">Task task;

using (AsyncContext.New())
{
    // starts in a new context
    var task = DoSomethingAsync(...);
}

// the entire task executes in the new context
await task;
</code></pre>
<p>Essentially, when the <code>using</code> block is exited, the previous <code>AsyncContext</code> is restored, but the new one that was created remains attached to the tasks that were started.</p>
<h2 id="explicit-context">Explicit Context</h2>
<p>On the other hand, <a href="distributed-objects/fencedlock.html">fenced locks</a>, which are part of the <a href="cpsubsystem.html">CP subsystem</a>, rely on an explicit object to represent the lock context. Every fenced lock operation requires a context, and operate on that context. Therefore, acquiring a lock is performed as:</p>
<pre><code class="lang-csharp">var context = new LockContext();
var lock = await client.CPSubSystem.GetLockAsync(lockName);
await lock.LockAsync(context);
// ...
await lock.UnlockAsync(context);
</code></pre>
<p>The lock context is re-entrant: it is possible to lock several times <em>for the same context</em> as long as the lock is unlocked the same number of times. On the other hand, trying to lock for any other context object would block.</p>
<p>It is up to the application code to manage the lock context appropriately.</p>

</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In this article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      Copyright &copy; 2010-2024 Hazelcast, Inc. All rights reserved.<br>Generated by DocFX.
      
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="../../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
