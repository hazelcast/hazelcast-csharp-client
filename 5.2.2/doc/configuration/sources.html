<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Configuration Sources | Hazelcast .NET Documentation </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Configuration Sources | Hazelcast .NET Documentation ">
    
      <link rel="shortcut icon" href="../../../images/favicon.ico">
      <link rel="stylesheet" href="../../../styles/docfx.vendor.min.css">
      <link rel="stylesheet" href="../../../styles/docfx.css">
      <link rel="stylesheet" href="../../../styles/main.css">
      <link rel="stylesheet" href="../../../styles/hz.css">
      <meta property="docfx:navrel" content="../../toc.html">
      <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper" class="">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" src="../../../images/hazelcast-white.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
              <div class="brandcrumb">.NET Client Documentation<br>5.2.2</div>
              <div id="breadhtml">
                <ul class="breadcrumb">
                  <li></li>
                </ul>
              </div>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="configuration-sources">Configuration Sources</h1>

<p>Configuration follows the <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration">Microsoft.Extensions.Configuration</a>
patterns. The Hazelcast client configuration is represented by the <a class="xref" href="../../api/Hazelcast.HazelcastOptions.html">HazelcastOptions</a> class. When simply instantiated, this
class contains the default options (i.e. it does not even read the options file):</p>
<pre><code class="lang-csharp">var options = new HazelcastOptions();
</code></pre>
<blockquote>
<p>For failover client, please see the <a href="../failover.html">failover documentation</a>.</p>
</blockquote>
<p>For anything more realistic though, different approaches are available, as detailed below.</p>
<p>This page does not document the options themselves. Options that can be configured are fully documented on the <a href="options.html">Options</a> page.</p>
<h3 id="simple-environment">Simple Environment</h3>
<p>In a simple, non-hosted environment without dependency injection, options need to be <em>built</em> using the
<a class="xref" href="../../api/Hazelcast.HazelcastOptionsBuilder.html">HazelcastOptionsBuilder</a>:</p>
<pre><code class="lang-csharp">public class Program
{
    public static void Main(string[] args)
    {
        var options = new HazelcastOptionsBuilder.With(args).Build();
    }
}
</code></pre>
<p>This will determine the application environment (<code>&lt;env&gt;</code>) from the <code>DOTNET_ENVIRONMENT</code> and <code>ASPNETCORE_ENVIRONMENT</code> variables (or, if not specified, default to <code>Production</code>), and then gather configuration keys from the following ordered sources:</p>
<ul>
<li>Optional default in-memory key/values</li>
<li><code>appsettings.json</code> file</li>
<li><code>appsettings.&lt;env&gt;.json</code> file</li>
<li>Environment variables (using double-underscore separator, e.g. <code>hazelcast__clientName</code>)</li>
<li>Command line arguments (using colon separator, e.g. <code>hazelcast:clientName</code>)</li>
<li><code>hazelcast.json</code> file</li>
<li><code>hazelcast.&lt;env&gt;.json</code> file</li>
<li>Hazelcast-specific environment variables (using dot separator, e.g. <code>hazelcast.clientName</code>)</li>
<li>Hazelcast-specific command line arguments (using dot separator, e.g. <code>hazelcast.clientName</code>)</li>
<li>Optional in-memory key/values</li>
</ul>
<p>The Hazelcast-specific sources for environment variables and command line arguments only exist to support the non-standard dot separator, and complement the original sources.</p>
<p>The <a class="xref" href="../../api/Hazelcast.HazelcastOptionsBuilder.html">HazelcastOptionsBuilder</a> provides ways to override the name and location of the <code>hazelcast.json</code> and
<code>hazelcast.&lt;env&gt;.json</code> files, the <code>&lt;env&gt;</code> environment name, and accepts optional in-memory key/values.</p>
<p>Every Hazelcast option can therefore be specified via the traditional .NET Core methods. For instance, specifying one
cluster server address can be done via the following Json fragment in any of the Json files:</p>
<pre><code class="lang-json">{
    &quot;hazelcast&quot;: {
        &quot;networking&quot;: {
            &quot;addresses&quot;: [ &quot;server:port&quot; ]
        }
    }
}
</code></pre>
<p>It can alternatively be specified by setting an environment variable (note that the dotted format may not be supported on every platform):</p>
<pre><code class="lang-sh">hazelcast__networking__addresses__0=server:port   ## supported on all platforms
hazelcast:networking:addresses:0=server:port      ## not supported on all platforms
hazelcast.networking.addresses.0=server:port
</code></pre>
<p>It can alternatively be specified with command line arguments:</p>
<pre><code class="lang-sh">$ myApp hazelcast:networking:addresses:0=server:port
$ myApp hazelcast.networking.addresses.0=server:port
</code></pre>
<p>All the .NET Core supported formats are supported (i.e. <code>/arg value</code>, <code>/arg=value</code>, <code>--arg value</code>, etc.). See
the <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/#command-line">documentation</a> for details.</p>
<p>The <a class="xref" href="../../api/Hazelcast.HazelcastOptionsBuilder.html">HazelcastOptionsBuilder</a> supports direct, in-memory key/values (with keys using either the dot or colon separator). There are two types of direct key/values. <em>Default</em> key/values are applied <em>before</em> everything else, and therefore can be overriden by, for instance, the command line, whereas <em>normal</em> key/values are applied <em>after</em> everything else, thus overriding other sources.</p>
<pre><code class="lang-csharp">var options = new HazelcastOptionsBuilder
    .WithDefault(&quot;hazelcast.networking.something&quot;, &quot;true&quot;)
    .With(&quot;hazelcast.networking.addresses.0&quot;, &quot;server:port&quot;)
    .Build();
</code></pre>
<p>The <a class="xref" href="../../api/Hazelcast.HazelcastOptionsBuilder.html">HazelcastOptionsBuilder</a> also supports providing actions that can modify the options via code. These actions will run before, and after, everything that has been described until now:</p>
<pre><code class="lang-csharp">var options = new HazelcastOptionsBuilder
    .WithDefault(o =&gt; o.Networking.Addresses.Clear())
    .With(o =&gt; o.Networking.Addresses.Add(&quot;127.0.0.1&quot;))
    .Build();
</code></pre>
<h3 id="container-environment">Container Environment</h3>
<p>In a container environment, one can rely on dependency injection to manage configuration. An <a class="xref" href="https://learn.microsoft.com/dotnet/api/microsoft.extensions.configuration.iconfiguration">IConfiguration</a> must be created, in order to add Hazelcast to the services:</p>
<pre><code class="lang-csharp">var configuration = new ConfigurationBuilder()
    // add default configuration (appsettings.json, etc)
    .AddDefaults(args)
    // add Hazelcast-specific configuration
    .AddHazelcast(args)
    .Build();

// create the service collection
var services = new ServiceCollection();

// add Hazelcast-specific services
services.AddHazelcast(configuration); 
</code></pre>
<p>Configuration keys will be gathered from the same sources and in the same order as before, and options will be registered in the service container, and available via dependency injection:</p>
<pre><code class="lang-csharp">public class MyService
{
    private readonly HazelcastOptions _options;

    public MyService(IOptions&lt;HazelcastOptions&gt; ioptions)
    {
        _options = ioptions.Value;
    }

    public async Task DoSomethingAsync()
    {
        await using var client = HazelcastClientFactory.StartNewClientAsync(_options);
        // ...
    }
}
</code></pre>
<p>Also, the traditional Microsoft Dependency Injection patterns are supported:</p>
<pre><code class="lang-csharp">services.Configure&lt;HazelcastOptions&gt;(options =&gt; 
{
    options.Networking.Addresses.Add(&quot;server:port&quot;);
});
</code></pre>
<p>Note: The required extension methods are not part of the Hazelcast.Net NuGet packages, but are provided as part of the <a href="https://www.nuget.org/packages/Hazelcast.Net.DependencyInjection/">Hazelcast.Net.DependencyInjection</a> project (on NuGet).</p>
<h3 id="hosted-environment">Hosted Environment</h3>
<p>In a .NET Core hosted environment (see <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host">.NET Generic Host</a>), the host supplies the <a class="xref" href="https://learn.microsoft.com/dotnet/api/microsoft.extensions.configuration.iconfiguration">IConfiguration</a> instance, and manages dependency injection. All that is needed is to tell the host how to handle the Hazelcast-specific configuration (e.g. <code>hazelcast.json</code>), and to add Hazelcast to services.</p>
<p>For example:</p>
<pre><code class="lang-csharp">Host.CreateDefaultBuilder(args)
    .ConfigureHazelcast(args) // configure Hazelcast services
    .ConfigureServices((hostingContext, services) =&gt;
    {
        services.AddHazelcast(hostingContext.Configuration); // register Hazelcast services
    });
</code></pre>
<p>Just as with the previous container environment, configuration keys will be gathered from the same sources and in the same order as before, and options will be registered in the service container, and available via dependency injection.</p>
<p>In a typical WebAPI application, this means that the <code>Program</code> class would probably contain code similar to:</p>
<pre><code class="lang-csharp">public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
    Host.CreateDefaultBuilder(args)
        .ConfigureHazelcast(args) // configure Hazelcast services
        .ConfigureWebHostDefaults(webBuilder =&gt;
        {
            webBuilder.UseStartup&lt;Startup&gt;(); 
        });
</code></pre>
<p>And the <code>Startup</code> class would probably contain code similar to:</p>
<pre><code class="lang-csharp">// This method gets called by the runtime. Use this method to add services to the container.
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
    services.AddHazelcast(Configuration); // register Hazelcast services

    // ... add more services ...
}
</code></pre>
<p>Note: The required extension methods are not part of the Hazelcast.Net NuGet packages, but are provided as part of the <a href="https://www.nuget.org/packages/Hazelcast.Net.DependencyInjection/">Hazelcast.Net.DependencyInjection</a> project (on NuGet).</p>
</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      Copyright &copy; 2010-2023 Hazelcast, Inc. All rights reserved.<br>Generated by DocFX.
      
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="../../../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
