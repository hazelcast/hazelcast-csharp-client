<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>FencedLock | Hazelcast .NET Documentation </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="FencedLock | Hazelcast .NET Documentation ">
    
      <link rel="shortcut icon" href="../../../images/favicon.ico">
      <link rel="stylesheet" href="../../../styles/docfx.vendor.min.css">
      <link rel="stylesheet" href="../../../styles/docfx.css">
      <link rel="stylesheet" href="../../../styles/main.css">
      <link rel="stylesheet" href="../../../styles/hz.css">
      <meta property="docfx:navrel" content="../../toc.html">
      <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper" class="">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" src="../../../images/hazelcast-white.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
              <div class="brandcrumb">.NET Client Documentation<br>5.5.0</div>
              <div id="breadhtml">
                <ul class="breadcrumb">
                  <li></li>
                </ul>
              </div>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="fencedlock">FencedLock</h1>

<div class="NOTE">
<h5>Note</h5>
<p>IFencedLock is a member of CP Subsystem API. For detailed information, see the <a href="../cpsubsystem.html">CP SubSystem documentation</a>.</p>
<p>The original <a href="https://docs.hazelcast.com/hazelcast/latest/data-structures/fencedlock">FencedLock documentation</a> may help get a
better understanding of the .NET IFencedLock implementation.</p>
</div>
<p>Hazelcast <a class="xref" href="../../api/Hazelcast.CP.IFencedLock.html">IFencedLock</a> is a linearizable and distributed implementation of <code>java.util.concurrent.locks.Lock</code>, meaning that if you lock using a FencedLock, the critical section that it guards is guaranteed to be executed by only one thread in the entire cluster. Even though locks are great for synchronization, they can lead to problems if not used properly. Also note that Hazelcast Lock does not support fairness.
Since <a class="xref" href="../../api/Hazelcast.CP.IFencedLock.html">IFencedLock</a> is a distributed implementation, these operations involve remote calls and thus their performances differ from local, in-memory, references.</p>
<p>IFencedLock is CP with respect to the CAP principle. It works on top of the Raft consensus algorithm. It offers
linearizability during crash-stop failures and network partitions. If a network partition occurs, it remains
available on at most one side of the partition.</p>
<p>By default, IFencedLock is reentrant. Once a caller acquires the lock, it can acquire the lock reentrantly as many
times as it wants in a linearizable manner. You can configure the reentrancy behavior via the cluster configuration.
For instance, reentrancy can be disabled and FencedLock can work as a non-reentrant mutex. You can also set a
custom reentrancy limit. When the reentrancy limit is already reached, IFencedLock does not block a lock call.
Instead, it fails with an exception or a specified return value.</p>
<p>Distributed locks are unfortunately not equivalent to single-node mutexes because of the complexities in distributed
systems, such as uncertain communication patterns, and independent and partial failures. In an asynchronous network,
no lock service can guarantee mutual exclusion, because there is no way to distinguish between a slow and a crashed
process. This can be mitigated with <em>fences</em> (see <a href="https://docs.hazelcast.com/hazelcast/latest/data-structures/fencedlock">FencedLock documentation</a>
for details): lock holders are ordered by a monotonic fencing token, which increments each time the lock is assigned
to a new owner. This fencing token can be passed to external services or resources to ensure sequential execution of
the side effects performed by lock holders.</p>
<h2 id="lock-context">Lock Context</h2>
<p>The original Java FencedLock is thread-based, much like the .NET <code>lock</code> statement is. In the distributed world, this
means that the <em>context</em> of a lock ownership is a unique thread, for a unique client connection. In other words, the
concept of <em>thread</em> is extended to the entire distributed system, and the lock context is this thread.</p>
<p>This however does not work well with .NET asynchronous programming model, just as the <code>lock</code> statement does not either.
Indeed, the following code is illegal (and would not compile) because the asynchronous <code>await</code> could cause the execution
flow to continue on any thread.</p>
<pre><code class="lang-csharp">lock (mutex) // locks acquired by the current thread
{
    // this is still the current thread
    await DoSomething();
    // this can be any thread!
}
</code></pre>
<p>In C# programming, developers know that they cannot mix the <code>lock</code> statement with asynchronous programming, and
typically use an explicit structure such as a semaphore, which becomes the lock context:</p>
<pre><code class="lang-csharp">await semaphore.WaitAsync();
try
{
    await DoSomething();
}
finally 
{
    semaphore.Release();
}
</code></pre>
<p>Hazelcast FencedLock provides, and requires, an explicit lock context object. Every FencedLock operation
executes within that context, which needs to be passed around in code. The code then becomes:</p>
<pre><code class="lang-csharp">var lockContext = new LockContext();
await fencedLock.LockAsync(lockContext);
try
{
    await DoSomething();
}
finally 
{
    await fencedLock.UnlockAsync(lockContext);
}
</code></pre>
<h2 id="example">Example</h2>
<p>The following simple example creates and uses a IFencedLock:</p>
<pre><code class="lang-csharp">var cancellationSource = new CancellationTokenSource();
var cancellationToken = cancellationSource.Token;

await using var client = await HazelcastClientFactory.StartNewClientAsync(options);
await using var fencedLock = await client.CPSubsystem.GetLockAsync(&quot;lock-name&quot;);

var lockContext = new LockContext();

await fencedLock.LockAsync(lockContext); // acquires the lock for lockContext (count = 1)
await fencedLock.LockAsync(lockContext); // re-enters the lock for lockContext (count = 2)

var otherContext = new LockContext();
var task = Task.Run(async () =&gt; {
    // acquires the lock for otherContext
    // blocks as long as the lock is owned by lockContext
    await fencedLock.LockAsync(otherContext);
});

await fencedLock.UnlockAsync(lockContext); // exits the lock for lockContext (count = 1)
await fencedLock.UnlockAsync(lockContext); // releases the lock for lockContext

await task; // completes now that lockContext does not own the lock anymore
await fencedLock.UnlockAsync(otherContext); // releases the lock for otherContext

await fencedLock.DestroyAsync();
</code></pre>
<h2 id="notes">Notes</h2>
<p>Locks are fail-safe. If a member holds a lock and some other members go down, the cluster will keep your
locks safe and available. Moreover, when a member leaves the cluster, all the locks acquired by that dead
member will be removed so that those locks are immediately available for live members.</p>
<p>Locks are not automatically removed. If a lock is not used anymore, Hazelcast does not automatically
perform garbage collection in the lock. This can lead to an OutOfMemoryError. If you create locks on
the fly, make sure they are destroyed.</p>
<p>Locks are re-entrant. The same context can lock multiple times on the same lock. Note that for other
contexts to be able to require this lock, the owner of the lock must call unlock as many times as the
owner called lock.</p>
<p>Refer to the <a href="https://docs.hazelcast.com/hazelcast/latest/data-structures/fencedlock">FencedLock documentation</a> for a</p>
<blockquote>
<p>better understanding of FencedLock, fencing, etc.</p>
</blockquote>

</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In this article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      Copyright &copy; 2010-2024 Hazelcast, Inc. All rights reserved.<br>Generated by DocFX.
      
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="../../../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
